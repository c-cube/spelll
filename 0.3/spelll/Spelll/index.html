<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Spelll (spelll.Spelll)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">spelll</a> &#x00BB; Spelll</nav><h1>Module <code>Spelll</code></h1><h2 id="levenshtein-distance-and-index"><a href="#levenshtein-distance-and-index" class="anchor"></a>Levenshtein distance and index</h2><p>We take inspiration from <a href="http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata">this blog</a> for the main algorithm and ideas. However some parts are adapted</p><nav class="toc"><ul><li><a href="#abstraction-over-strings">Abstraction over Strings</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#signature">Signature</a></li></ul></nav></header><section><header><h3 id="abstraction-over-strings"><a href="#abstraction-over-strings" class="anchor"></a>Abstraction over Strings</h3><p>Due to the existence of several encodings and string representations we abstract over the type of strings. A string is a finite array of characters (8-bits char, unicode runes, etc.) which provides a length operation and a function to access the n-th character.</p></header><div class="spec module-type" id="module-type-STRING"><a href="#module-type-STRING" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-STRING/index.html">STRING</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h3><p>We use <span class="xref-unresolved" title="unresolved reference to &quot;Seq.t&quot;"><code>Seq</code>.t</span> to provide universal iterators. This data structure is used to represent a list of result that is evaluated only as far as the user wants. If the user only wants a few elements, they don't pay for the remaining ones.</p><p>In particular, when matching a string against a (big) set of indexed strings, we return a continuation list so that, even if there are many results, only those actually asked for are evaluated.</p></header><dl><dt class="spec value" id="val-list_of_seq"><a href="#val-list_of_seq" class="anchor"></a><code><span class="keyword">val</span> list_of_seq : <span class="type-var">'a</span> Seq.t <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Helper.</p></dd></dl></section><section><header><h3 id="signature"><a href="#signature" class="anchor"></a>Signature</h3><p>The signature for a given string representation provides 3 main things:</p><ul><li>a <code>edit_distance</code> function to compute the edit distance between strings</li><li>an <code>automaton</code> type that is built from a string <code>s</code> and a maximum distance <code>n</code>, and only accepts the strings <code>s'</code> such that <code>edit_distance s s' &lt;= n</code>.</li><li>an <code>Index</code> module that can be used to map many strings to values, like a regular string map, but for which retrieval is fuzzy (for a given maximal distance).</li></ul><p>A possible use of the index could be:</p><pre><code class="ml">let words = CCIO.with_in &quot;/usr/share/dict/english&quot; CCIO.read_lines_l ;;

let words = List.map (fun s-&gt;s,s) words;;
let idx = Spelll.Index.of_list words;;

Spelll.Index.retrieve_l ~limit:1 idx &quot;hell&quot; ;;</code></pre><p>Here we use <a href="https://github.com/c-cube/ocaml-containers">Containers</a> to read a dictionary file into a list of words; then we create an index that maps every string to itself (a set of strings, really), and finally we find every string at distance at most 1 from &quot;hell&quot; (including &quot;hello&quot; for instance).</p></header><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Str/index.html">Str</a> : <a href="index.html#module-type-STRING">STRING</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-string_">string_</a> = <a href="Make/argument-1-Str/index.html#type-t">Str.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make/index.html#type-char_">char_</a> = <a href="Make/argument-1-Str/index.html#type-char_">Str.char_</a></code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-type-S">S</a>.char_ = char <span class="keyword">and</span> <span class="keyword">type</span> <a href="index.html#module-type-S">S</a>.string_ = string</code></span></summary><dl><dt class="spec type" id="type-char_"><a href="#type-char_" class="anchor"></a><code><span class="keyword">type</span> char_</code><code> = char</code></dt><dt class="spec type" id="type-string_"><a href="#type-string_" class="anchor"></a><code><span class="keyword">type</span> string_</code><code> = string</code></dt></dl><dl><dt class="spec value" id="val-edit_distance"><a href="#val-edit_distance" class="anchor"></a><code><span class="keyword">val</span> edit_distance : <a href="index.html#type-string_">string_</a> <span>&#45;&gt;</span> <a href="index.html#type-string_">string_</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Edition distance between two strings. This satisfies the classical distance axioms: it is always positive, symmetric, and satisfies the formula <code>distance a b + distance b c &gt;= distance a c</code></p></dd></dl><dl><dt class="spec type" id="type-automaton"><a href="#type-automaton" class="anchor"></a><code><span class="keyword">type</span> automaton</code></dt><dd><p>Levenshtein automaton</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : limit:int <span>&#45;&gt;</span> <a href="index.html#type-string_">string_</a> <span>&#45;&gt;</span> <a href="index.html#type-automaton">automaton</a></code></dt><dd><p>Build an automaton from a string, with a maximal distance <code>limit</code>. The automaton will accept strings whose <a href="index.html#val-edit_distance"><code>edit_distance</code></a> to the parameter is at most <code>limit</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : limit:int <span>&#45;&gt;</span> <a href="index.html#type-char_">char_</a> list <span>&#45;&gt;</span> <a href="index.html#type-automaton">automaton</a></code></dt><dd><p>Build an automaton from a list, with a maximal distance <code>limit</code></p></dd></dl><dl><dt class="spec value" id="val-debug_print"><a href="#val-debug_print" class="anchor"></a><code><span class="keyword">val</span> debug_print : (Pervasives.out_channel <span>&#45;&gt;</span> <a href="index.html#type-char_">char_</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> Pervasives.out_channel <span>&#45;&gt;</span> <a href="index.html#type-automaton">automaton</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Output the automaton's structure on the given channel.</p></dd></dl><dl><dt class="spec value" id="val-match_with"><a href="#val-match_with" class="anchor"></a><code><span class="keyword">val</span> match_with : <a href="index.html#type-automaton">automaton</a> <span>&#45;&gt;</span> <a href="index.html#type-string_">string_</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>match_with a s</code> matches the string <code>s</code> against <code>a</code>, and returns <code>true</code> if the distance from <code>s</code> to the word represented by <code>a</code> is smaller than the limit used to build <code>a</code></p></dd></dl><div class="spec module" id="module-Index"><a href="#module-Index" class="anchor"></a><code><span class="keyword">module</span> <a href="Index/index.html">Index</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><dl><dt class="spec value" id="val-debug_print"><a href="#val-debug_print" class="anchor"></a><code><span class="keyword">val</span> debug_print : Pervasives.out_channel <span>&#45;&gt;</span> <a href="index.html#type-automaton">automaton</a> <span>&#45;&gt;</span> unit</code></dt></dl></section></div></body></html>